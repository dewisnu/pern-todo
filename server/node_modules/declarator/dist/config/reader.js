"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseConfig = exports.readConfig = exports.possibleFilenames = void 0;
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const path_1 = __importDefault(require("path"));
const log_1 = require("../util/log");
const defaults_1 = require("./defaults");
/**
 * The list of possible filenames for the configuration file. Package.json is checked separately.
 */
exports.possibleFilenames = [
    'declarator.js',
    'declarator.json',
    '.declarator.js',
    '.declarator.json',
    '.declaratorrc',
    '.declaratorrc.js',
    '.declaratorrc.json'
];
/**
 *
 * Attempts to read or create a configuration file for the specified directory.
 *
 * @param directory the directory to find the file
 * @returns the read config or a newly created one
 */
async function readConfig(directory = process.cwd()) {
    for (const possibleFile of exports.possibleFilenames) {
        const name = path_1.default.join(directory, possibleFile);
        try {
            return require(name);
        }
        catch {
            log_1.log.debug `${name} could not be found.`;
            // no empty block
            continue;
        }
    }
    // Try finding it at package.json
    const packagePath = path_1.default.join(directory, 'package.json');
    try {
        const packageJson = await require(packagePath);
        const declarator = packageJson['declarator'];
        if (!declarator) {
            log_1.log.debug `${packagePath} does not contain a declarator section.`;
            // Skips to catch block
            throw null;
        }
        return declarator;
    }
    catch (err) {
        // no config found.
        log_1.log.info `No config file could be found. Tried (${exports.possibleFilenames})`;
        return defaults_1.defaultOptions;
    }
}
exports.readConfig = readConfig;
/**
 * Parses the read config and merge any empty property with the defaults
 *
 * @param config the partial config that was read
 * @returns the complete config merged with defaults
 */
function parseConfig(config) {
    const read = typeof config === 'function' ? config() : config;
    return (0, lodash_merge_1.default)(defaults_1.defaultOptions, read);
}
exports.parseConfig = parseConfig;
//# sourceMappingURL=reader.js.map